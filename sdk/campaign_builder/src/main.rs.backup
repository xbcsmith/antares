// SPDX-FileCopyrightText: 2025 Brett Smith <xbcsmith@gmail.com>
// SPDX-License-Identifier: Apache-2.0

//! Campaign Builder - Phase 2: Foundation UI for Antares SDK
//!
//! Phase 2 adds:
//! - Full metadata editor with all campaign.ron fields
//! - Real file I/O (save/load campaign.ron)
//! - Enhanced validation UI with detailed error reporting
//! - File structure browser showing campaign directory layout
//! - Placeholder list views for Items, Spells, Monsters, Maps, Quests
//! - Unsaved changes tracking and warnings

use eframe::egui;
use serde::{Deserialize, Serialize};
use std::fs;
use std::path::PathBuf;
use thiserror::Error;

fn main() -> Result<(), eframe::Error> {
    let options = eframe::NativeOptions {
        viewport: egui::ViewportBuilder::default()
            .with_inner_size([1280.0, 720.0])
            .with_min_inner_size([800.0, 600.0])
            .with_title("Antares Campaign Builder - Phase 2"),

        renderer: eframe::Renderer::default(),
        ..Default::default()
    };

    eframe::run_native(
        "Antares Campaign Builder",
        options,
        Box::new(|_cc| Ok(Box::<CampaignBuilderApp>::default())),
    )
}

/// Campaign metadata structure matching campaign.ron schema
#[derive(Debug, Clone, Serialize, Deserialize)]
struct CampaignMetadata {
    id: String,
    name: String,
    version: String,
    author: String,
    description: String,
    engine_version: String,

    // Campaign configuration
    starting_map: String,
    starting_position: (u32, u32),
    starting_direction: String,
    starting_gold: u32,
    starting_food: u32,
    max_party_size: usize,
    max_roster_size: usize,
    difficulty: Difficulty,
    permadeath: bool,
    allow_multiclassing: bool,
    starting_level: u8,
    max_level: u8,

    // Data file paths
    items_file: String,
    spells_file: String,
    monsters_file: String,
    classes_file: String,
    races_file: String,
    maps_dir: String,
    quests_file: String,
    dialogue_file: String,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
enum Difficulty {
    Easy,
    Normal,
    Hard,
    Brutal,
}

impl Default for Difficulty {
    fn default() -> Self {
        Difficulty::Normal
    }
}

impl Difficulty {
    fn as_str(&self) -> &str {
        match self {
            Difficulty::Easy => "Easy",
            Difficulty::Normal => "Normal",
            Difficulty::Hard => "Hard",
            Difficulty::Brutal => "Brutal",
        }
    }

    fn all() -> [Difficulty; 4] {
        [Difficulty::Easy, Difficulty::Normal, Difficulty::Hard, Difficulty::Brutal]
    }
}

impl Default for CampaignMetadata {
    fn default() -> Self {
        Self {
            id: String::new(),
            name: String::new(),
            version: "1.0.0".to_string(),
            author: String::new(),
            description: String::new(),
            engine_version: "0.1.0".to_string(),

            starting_map: "starter_town".to_string(),
            starting_position: (10, 10),
            starting_direction: "North".to_string(),
            starting_gold: 100,
            starting_food: 10,
            max_party_size: 6,
            max_roster_size: 20,
            difficulty: Difficulty::Normal,
            permadeath: false,
            allow_multiclassing: false,
            starting_level: 1,
            max_level: 20,

            items_file: "data/items.ron".to_string(),
            spells_file: "data/spells.ron".to_string(),
            monsters_file: "data/monsters.ron".to_string(),
            classes_file: "data/classes.ron".to_string(),
            races_file: "data/races.ron".to_string(),
            maps_dir: "data/maps/".to_string(),
            quests_file: "data/quests.ron".to_string(),
            dialogue_file: "data/dialogue.ron".to_string(),
        }
    }
}

/// Active tab in the UI
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum EditorTab {
    Metadata,
    Config,
    Items,
    Spells,
    Monsters,
    Maps,
    Quests,
    Files,
    Validation,
}

impl EditorTab {
    fn name(&self) -> &str {
        match self {
            EditorTab::Metadata => "üìã Metadata",
            EditorTab::Config => "‚öôÔ∏è Config",
            EditorTab::Items => "‚öîÔ∏è Items",
            EditorTab::Spells => "‚ú® Spells",
            EditorTab::Monsters => "üëπ Monsters",
            EditorTab::Maps => "üó∫Ô∏è Maps",
            EditorTab::Quests => "üìú Quests",
            EditorTab::Files => "üìÅ Files",
            EditorTab::Validation => "‚úÖ Validation",
        }
    }
}

/// Validation error with severity
#[derive(Debug, Clone)]
struct ValidationError {
    severity: Severity,
    message: String,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum Severity {
    Error,
    Warning,
}

impl Severity {
    fn icon(&self) -> &str {
        match self {
            Severity::Error => "‚ùå",
            Severity::Warning => "‚ö†Ô∏è",
        }
    }
}

/// File I/O errors
#[derive(Debug, Error)]
enum CampaignError {
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),

    #[error("RON serialization error: {0}")]
    Serialization(#[from] ron::Error),

    #[error("RON deserialization error: {0}")]
    Deserialization(#[from] ron::error::SpannedError),

    #[error("No campaign path set")]
    NoPath,
}

/// Main application state
struct CampaignBuilderApp {
    campaign: CampaignMetadata,
    active_tab: EditorTab,
    campaign_path: Option<PathBuf>,
    campaign_dir: Option<PathBuf>,
    status_message: String,
    unsaved_changes: bool,
    validation_errors: Vec<ValidationError>,
    show_about_dialog: bool,
    show_unsaved_warning: bool,
    pending_action: Option<PendingAction>,
    file_tree: Vec<FileNode>,
}

#[derive(Debug, Clone)]
enum PendingAction {
    New,
    Open,
    Exit,
}

#[derive(Debug, Clone)]
struct FileNode {
    name: String,
    path: PathBuf,
    is_directory: bool,
    children: Vec<FileNode>,
}

impl Default for CampaignBuilderApp {
    fn default() -> Self {
        Self {
            campaign: CampaignMetadata::default(),
            active_tab: EditorTab::Metadata,
            campaign_path: None,
            campaign_dir: None,
            status_message: "Ready. Create a new campaign or open an existing one.".to_string(),
            unsaved_changes: false,
            validation_errors: Vec::new(),
            show_about_dialog: false,
            show_unsaved_warning: false,
            pending_action: None,
            file_tree: Vec::new(),
        }
    }
}

impl CampaignBuilderApp {
    /// Validate the campaign metadata
    fn validate_campaign(&mut self) {
        self.validation_errors.clear();

        // Required fields
        if self.campaign.id.is_empty() {
            self.validation_errors.push(ValidationError {
                severity: Severity::Error,
                message: "Campaign ID is required".to_string(),
            });
        } else if !self.campaign.id.chars().all(|c| c.is_alphanumeric() || c == '_') {
            self.validation_errors.push(ValidationError {
                severity: Severity::Error,
                message: "Campaign ID must contain only alphanumeric characters and underscores".to_string(),
            });
        }

        if self.campaign.name.is_empty() {
            self.validation_errors.push(ValidationError {
                severity: Severity::Error,
                message: "Campaign name is required".to_string(),
            });
        }

        if self.campaign.author.is_empty() {
            self.validation_errors.push(ValidationError {
                severity: Severity::Warning,
                message: "Author name is recommended".to_string(),
            });
        }

        // Version validation
        if !self.campaign.version.contains('.') {
            self.validation_errors.push(ValidationError {
                severity: Severity::Error,
                message: "Version should follow semantic versioning (e.g., 1.0.0)".to_string(),
            });
        }

        // Engine version validation
        if !self.campaign.engine_version.contains('.') {
            self.validation_errors.push(ValidationError {
                severity: Severity::Warning,
                message: "Engine version should follow semantic versioning".to_string(),
            });
        }

        // Configuration validation
        if self.campaign.starting_map.is_empty() {
            self.validation_errors.push(ValidationError {
                severity: Severity::Error,
                message: "Starting map is required".to_string(),
            });
        }

        if self.campaign.max_party_size == 0 || self.campaign.max_party_size > 10 {
            self.validation_errors.push(ValidationError {
                severity: Severity::Warning,
                message: "Max party size should be between 1 and 10".to_string(),
            });
        }

        if self.campaign.max_roster_size < self.campaign.max_party_size {
            self.validation_errors.push(ValidationError {
                severity: Severity::Error,
                message: "Max roster size must be >= max party size".to_string(),
            });
        }

        if self.campaign.starting_level == 0 || self.campaign.starting_level > self.campaign.max_level {
            self.validation_errors.push(ValidationError {
                severity: Severity::Error,
                message: "Starting level must be between 1 and max level".to_string(),
            });
        }

        // File path validation
        for (field, path) in [
            ("Items file", &self.campaign.items_file),
            ("Spells file", &self.campaign.spells_file),
            ("Monsters file", &self.campaign.monsters_file),
            ("Classes file", &self.campaign.classes_file),
            ("Races file", &self.campaign.races_file),
            ("Quests file", &self.campaign.quests_file),
            ("Dialogue file", &self.campaign.dialogue_file),
        ] {
            if path.is_empty() {
                self.validation_errors.push(ValidationError {
                    severity: Severity::Error,
                    message: format!("{} path is required", field),
                });
            } else if !path.ends_with(".ron") {
                self.validation_errors.push(ValidationError {
                    severity: Severity::Warning,
                    message: format!("{} should use .ron extension", field),
                });
            }
        }

        // Update status
        let error_count = self.validation_errors.iter()
            .filter(|e| e.severity == Severity::Error)
            .count();
        let warning_count = self.validation_errors.iter()
            .filter(|e| e.severity == Severity::Warning)
            .count();

        if self.validation_errors.is_empty() {
            self.status_message = "‚úÖ Validation passed!".to_string();
        } else {
            self.status_message = format!(
                "Validation: {} error(s), {} warning(s)",
                error_count, warning_count
            );
        }
    }

    /// Create a new campaign
    fn new_campaign(&mut self) {
        if self.unsaved_changes {
            self.show_unsaved_warning = true;
            self.pending_action = Some(PendingAction::New);
        } else {
            self.do_new_campaign();
        }
    }

    fn do_new_campaign(&mut self) {
        self.campaign = CampaignMetadata::default();
        self.campaign_path = None;
        self.campaign_dir = None;
        self.unsaved_changes = false;
        self.validation_errors.clear();
        self.file_tree.clear();
        self.status_message = "New campaign created.".to_string();
    }

    /// Save campaign to file
    fn save_campaign(&mut self) -> Result<(), CampaignError> {
        if self.campaign_path.is_none() {
            return Err(CampaignError::NoPath);
        }

        self.do_save_campaign()
    }

    fn do_save_campaign(&mut self) -> Result<(), CampaignError> {
        let path = self.campaign_path.as_ref().ok_or(CampaignError::NoPath)?;

        // Serialize to RON format with pretty printing
        let ron_config = ron::ser::PrettyConfig::new()
            .struct_names(true)
            .enumerate_arrays(false)
            .depth_limit(4);

        let ron_string = ron::ser::to_string_pretty(&self.campaign, ron_config)?;

        // Write to file
        fs::write(path, ron_string)?;

        self.unsaved_changes = false;
        self.status_message = format!("Campaign saved to: {}", path.display());

        // Update file tree if we have a campaign directory
        if let Some(dir) = &self.campaign_dir {
            self.update_file_tree(dir);
        }

        Ok(())
    }

    /// Save campaign as (with file dialog)
    fn save_campaign_as(&mut self) {
        if let Some(path) = rfd::FileDialog::new()
            .set_file_name("campaign.ron")
            .add_filter("RON Files", &["ron"])
            .save_file()
        {
            self.campaign_path = Some(path.clone());

            // Set campaign directory (parent of campaign.ron)
            if let Some(parent) = path.parent() {
                self.campaign_dir = Some(parent.to_path_buf());
            }

            match self.do_save_campaign() {
                Ok(()) => {},
                Err(e) => {
                    self.status_message = format!("Failed to save: {}", e);
                }
            }
        }
    }

    /// Open campaign from file
    fn open_campaign(&mut self) {
        if self.unsaved_changes {
            self.show_unsaved_warning = true;
            self.pending_action = Some(PendingAction::Open);
        } else {
            self.do_open_campaign();
        }
    }

    fn do_open_campaign(&mut self) {
        if let Some(path) = rfd::FileDialog::new()
            .add_filter("RON Files", &["ron"])
            .pick_file()
        {
            match self.load_campaign_file(&path) {
                Ok(()) => {
                    self.campaign_path = Some(path.clone());

                    // Set campaign directory
                    if let Some(parent) = path.parent() {
                        self.campaign_dir = Some(parent.to_path_buf());
                        self.update_file_tree(parent);
                    }

                    self.unsaved_changes = false;
                    self.status_message = format!("Opened campaign from: {}", path.display());
                }
                Err(e) => {
                    self.status_message = format!("Failed to load campaign: {}", e);
                }
            }
        }
    }

    fn load_campaign_file(&mut self, path: &PathBuf) -> Result<(), CampaignError> {
        let contents = fs::read_to_string(path)?;
        self.campaign = ron::from_str(&contents)?;
        Ok(())
    }

    /// Update the file tree view
    fn update_file_tree(&mut self, dir: &PathBuf) {
        self.file_tree.clear();

        if let Ok(entries) = fs::read_dir(dir) {
            for entry in entries.flatten() {
                if let Ok(metadata) = entry.metadata() {
                    let path = entry.path();
                    let name = entry.file_name().to_string_lossy().to_string();

                    let node = FileNode {
                        name,
                        path: path.clone(),
                        is_directory: metadata.is_dir(),
                        children: if metadata.is_dir() {
                            self.read_directory(&path)
                        } else {
                            Vec::new()
                        },
                    };

                    self.file_tree.push(node);
                }
            }
        }

        // Sort: directories first, then alphabetically
        self.file_tree.sort_by(|a, b| {
            match (a.is_directory, b.is_directory) {
                (true, false) => std::cmp::Ordering::Less,
                (false, true) => std::cmp::Ordering::Greater,
                _ => a.name.cmp(&b.name),
            }
        });
    }

    fn read_directory(&self, dir: &PathBuf) -> Vec<FileNode> {
        let mut children = Vec::new();

        if let Ok(entries) = fs::read_dir(dir) {
            for entry in entries.flatten() {
                if let Ok(metadata) = entry.metadata() {
                    let path = entry.path();
                    let name = entry.file_name().to_string_lossy().to_string();

                    children.push(FileNode {
                        name,
                        path,
                        is_directory: metadata.is_dir(),
                        children: Vec::new(), // Don't recurse deeper for now
                    });
                }
            }
        }

        children.sort_by(|a, b| {
            match (a.is_directory, b.is_directory) {
                (true, false) => std::cmp::Ordering::Less,
                (false, true) => std::cmp::Ordering::Greater,
                _ => a.name.cmp(&b.name),
            }
        });

        children
    }

    /// Check for unsaved changes before action
    fn check_unsaved_and_exit(&mut self) {
        if self.unsaved_changes {
            self.show_unsaved_warning = true;
            self.pending_action = Some(PendingAction::Exit);
        } else {
            std::process::exit(0);
        }
    }
}

impl eframe::App for CampaignBuilderApp {
    fn update(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame) {
        // Top menu bar
        egui::TopBottomPanel::top("menu_bar").show(ctx, |ui| {
            egui::menu::bar(ui, |ui| {
                ui.menu_button("File", |ui| {
                    if ui.button("üÜï New Campaign").clicked() {
                        self.new_campaign();
                        ui.close_menu();
                    }
                    if ui.button("üìÇ Open Campaign...").clicked() {
                        self.open_campaign();
                        ui.close_menu();
                    }
                    if ui.button("üíæ Save").clicked() {
                        if self.campaign_path.is_some() {
                            if let Err(e) = self.save_campaign() {
                                self.status_message = format!("Save failed: {}", e);
                            }
                        } else {
                            self.save_campaign_as();
                        }
                        ui.close_menu();
                    }
                    if ui.button("üíæ Save As...").clicked() {
                        self.save_campaign_as();
                        ui.close_menu();
                    }
                    ui.separator();
                    if ui.button("üö™ Exit").clicked() {
                        self.check_unsaved_and_exit();
                        ui.close_menu();
                    }
                });

                ui.menu_button("Tools", |ui| {
                    if ui.button("‚úÖ Validate Campaign").clicked() {
                        self.validate_campaign();
                        self.active_tab = EditorTab::Validation;
                        ui.close_menu();
                    }
                    if ui.button("üîÑ Refresh File Tree").clicked() {
                        if let Some(dir) = &self.campaign_dir.clone() {
                            self.update_file_tree(dir);
                            self.status_message = "File tree refreshed.".to_string();
                        }
                        ui.close_menu();
                    }
                    ui.separator();
                    if ui.button("üß™ Test Play").clicked() {
                        self.status_message = "Test play would launch the game here...".to_string();
                        ui.close_menu();
                    }
                    if ui.button("üì¶ Export Campaign...").clicked() {
                        self.status_message = "Export would create .zip archive here...".to_string();
                        ui.close_menu();
                    }
                });

                ui.menu_button("Help", |ui| {
                    if ui.button("üìñ Documentation").clicked() {
                        self.status_message = "Would open documentation in browser...".to_string();
                        ui.close_menu();
                    }
                    if ui.button("‚ÑπÔ∏è About").clicked() {
                        self.show_about_dialog = true;
                        ui.close_menu();
                    }
                });

                // Right-aligned status
                ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                    if self.unsaved_changes {
                        ui.colored_label(egui::Color32::from_rgb(255, 165, 0), "‚óè Unsaved changes");
                    } else {
                        ui.colored_label(egui::Color32::from_rgb(0, 200, 0), "‚úì Saved");
                    }
                });
            });
        });

        // Left sidebar with tabs
        egui::SidePanel::left("tab_panel")
            .resizable(false)
            .exact_width(150.0)
            .show(ctx, |ui| {
                ui.heading("Editors");
                ui.separator();

                let tabs = [
                    EditorTab::Metadata,
                    EditorTab::Config,
                    EditorTab::Items,
                    EditorTab::Spells,
                    EditorTab::Monsters,
                    EditorTab::Maps,
                    EditorTab::Quests,
                    EditorTab::Files,
                    EditorTab::Validation,
                ];

                for tab in &tabs {
                    let is_selected = self.active_tab == *tab;
                    if ui.selectable_label(is_selected, tab.name()).clicked() {
                        self.active_tab = *tab;
                    }
                }

                ui.separator();
                ui.label("Phase 2: Foundation");
                ui.label("Powered by egui");
            });

        // Bottom status bar
        egui::TopBottomPanel::bottom("status_bar").show(ctx, |ui| {
            ui.horizontal(|ui| {
                ui.label("Status:");
                ui.label(&self.status_message);

                if let Some(path) = &self.campaign_path {
                    ui.separator();
                    ui.label(format!("Path: {}", path.display()));
                }
            });
        });

        // Central panel with editor content
        egui::CentralPanel::default().show(ctx, |ui| match self.active_tab {
            EditorTab::Metadata => self.show_metadata_editor(ui),
            EditorTab::Config => self.show_config_editor(ui),
            EditorTab::Items => self.show_items_editor(ui),
            EditorTab::Spells => self.show_spells_editor(ui),
            EditorTab::Monsters => self.show_monsters_editor(ui),
            EditorTab::Maps => self.show_maps_editor(ui),
            EditorTab::Quests => self.show_quests_editor(ui),
            EditorTab::Files => self.show_file_browser(ui),
            EditorTab::Validation => self.show_validation_panel(ui),
        });

        // About dialog
        if self.show_about_dialog {
            egui::Window::new("About Antares Campaign Builder")
                .collapsible(false)
                .resizable(false)
                .show(ctx, |ui| {
                    ui.vertical_centered(|ui| {
                        ui.heading("Antares Campaign Builder");
                        ui.label("Phase 2: Foundation v0.2.0");
                        ui.separator();
                        ui.label("A visual editor for creating custom");
                        ui.label("campaigns for the Antares RPG engine.");
                        ui.separator();
                        ui.label("Phase 2 Features:");
                        ui.label("‚úì Full metadata editing");
                        ui.label("‚úì Real file I/O (campaign.ron)");
                        ui.label("‚úì Enhanced validation UI");
                        ui.label("‚úì File structure browser");
                        ui.label("‚úì Data editor placeholders");
                        ui.separator();
                        ui.label("Built with egui - works without GPU!");
                        ui.separator();
                        if ui.button("Close").clicked() {
                            self.show_about_dialog = false;
                        }
                    });
                });
        }

        // Unsaved changes warning
        if self.show_unsaved_warning {
            egui::Window::new("Unsaved Changes")
                .collapsible(false)
                .resizable(false)
                .show(ctx, |ui| {
                    ui.label("You have unsaved changes.");
                    ui.label("Do you want to save before continuing?");
                    ui.separator();

                    ui.horizontal(|ui| {
                        if ui.button("üíæ Save").clicked() {
                            if self.campaign_path.is_some() {
                                let _ = self.save_campaign();
                            } else {
                                self.save_campaign_as();
                            }

                            // Execute pending action
                            if let Some(action) = self.pending_action.take() {
                                match action {
                                    PendingAction::New => self.do_new_campaign(),
                                    PendingAction::Open => self.do_open_campaign(),
                                    PendingAction::Exit => std::process::exit(0),
                                }
                            }

                            self.show_unsaved_warning = false;
                        }

                        if ui.button("üö´ Don't Save").clicked() {
                            // Execute pending action without saving
                            if let Some(action) = self.pending_action.take() {
                                match action {
                                    PendingAction::New => self.do_new_campaign(),
                                    PendingAction::Open => self.do_open_campaign(),
                                    PendingAction::Exit => std::process::exit(0),
                                }
                            }

                            self.show_unsaved_warning = false;
                        }

                        if ui.button("‚ùå Cancel").clicked() {
                            self.show_unsaved_warning = false;
                            self.pending_action = None;
                        }
                    });
                });
        }
    }
}

impl CampaignBuilderApp {
    /// Show the metadata editor
    fn show_metadata_editor(&mut self, ui: &mut egui::Ui) {
        ui.heading("Campaign Metadata");
        ui.add_space(5.0);
        ui.label("Basic information about your campaign");
        ui.separator();

        egui::ScrollArea::vertical().show(ui, |ui| {
            egui::Grid::new("metadata_grid")
                .num_columns(2)
                .spacing([10.0, 8.0])
                .striped(true)
                .show(ui, |ui| {
                    // Campaign ID
                    ui.label("Campaign ID:");
                    if ui.text_edit_singleline(&mut self.campaign.id).changed() {
                        self.unsaved_changes = true;
                    }
                    ui.end_row();

                    // Campaign Name
                    ui.label("Name:");
                    if ui.text_edit_singleline(&mut self.campaign.name).changed() {
                        self.unsaved_changes = true;
                    }
                    ui.end_row();

                    // Version
                    ui.label("Version:");
                    if ui.text_edit_singleline(&mut self.campaign.version).changed() {
                        self.unsaved_changes = true;
                    }
                    ui.end_row();

                    // Author
                    ui.label("Author:");
                    if ui.text_edit_singleline(&mut self.campaign.author).changed() {
                        self.unsaved_changes = true;
                    }
                    ui.end_row();

                    // Engine Version
                    ui.label("Engine Version:");
                    if ui.text_edit_singleline(&mut self.campaign.engine_version).changed() {
                        self.unsaved_changes = true;
                    }
                    ui.end_row();
                });

            ui.add_space(10.0);
            ui.label("Description:");
            if ui.text_edit_multiline(&mut self.campaign.description)
                .desired_width(f32::INFINITY)
                .desired_rows(6)
                .changed()
            {
                self.unsaved_changes = true;
            }

            ui.add_space(10.0);
            ui.separator();

            ui.horizontal(|ui| {
                if ui.button("üíæ Save Campaign").clicked() {
                    if self.campaign_path.is_some() {
                        if let Err(e) = self.save_campaign() {
                            self.status_message = format!("Save failed: {}", e);
                        }
                    } else {
                        self.save_campaign_as();
                    }
                }

                if ui.button("‚úÖ Validate").clicked() {
                    self.validate_campaign();
                    self.active_tab = EditorTab::Validation;
                }
            });
        });
    }

    /// Show the configuration editor
    fn show_config_editor(&mut self, ui: &mut egui::Ui) {
        ui.heading("Campaign Configuration");
        ui.add_space(5.0);
        ui.label("Game rules and starting conditions");
        ui.separator();

        egui::ScrollArea::vertical().show(ui, |ui| {
            ui.group(|ui| {
                ui.heading("Starting Conditions");
